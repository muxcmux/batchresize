#!/usr/bin/env ruby
require 'optparse'
require 'logger'

LOGGER = Logger.new($stdout)
LOGGER.formatter = proc do |severity, datetime, progname, msg|
  "##{Process.pid} #{severity}: #{msg}\n"
end

%w(rmagick xpool).each do |lib|
  begin
    require lib
  rescue LoadError
    LOGGER.fatal "#{lib} not found. Install with `gem install #{lib}`"
    exit
  end
end


options = {
  :target => '',
  :destination => '',
  :size => '960x720',
  :concurrency => 5,
}

optparse = OptionParser.new do |opts|
  opts.on('-t', '--target DIR', 'Source directory that contains jpegs to be converted') do |dir|
    options[:target] = dir
    options[:target] << '/' if dir[-1] != '/'
  end
  
  opts.on('-d', '--destination DIR', 'Directory to place images after resizing') do |dir|
    options[:destination] = dir
    options[:destination] << '/' if dir[-1] != '/'
  end
  
  opts.on('-s', '--size [SIZE]', 'Required image size defaults to 960x720') do |size|
    options[:size] = size
  end
  
  opts.on('-c', '--concurrency [WORKERS]', Integer, 'Number of images to process simultaneously defaults to 5') do |workers|
    options[:concurrency] = workers
  end
  
  opts.on('-q', '--quiet', 'Silence output') do
    LOGGER.level = Logger::FATAL
  end
  
  opts.on('-h', '--help', 'Print this message') do
    puts opts
    exit
  end
end
optparse.parse!

if options[:target].empty? || options[:destination].empty?
  puts optparse
  exit
end

class Resizer
  def initialize target_dir, target_file, destination_dir, size
    @target_dir = target_dir
    @target_file = target_file
    @destination_dir = destination_dir
    @filename = @target_file.split('/').last
    @relative_filename = @target_file.sub(@target_dir, '')
    @relative_dir = @relative_filename.sub(@filename, '')
    @size = size
    mksubdir
  end
  
  def run
    LOGGER.info "Started processing: #{@target_file}"
    img = Magick::Image.read(@target_file).first
    width, height = @size.split('x')
    @size = "#{height}x#{width}" if img.rows > img.columns
    filename = "#{@relative_dir}#{@size}_#{@filename}"
    destination = "#{@destination_dir}#{filename}"
    begin
      img.change_geometry!(@size) do |cols, rows, image|
        newimg = img.resize(cols, rows)
        newimg.write(destination)
      end
    rescue Exception => e
      LOGGER.fatal "Failed to create #{destination}. Original message: #{e.message}"
    end
    LOGGER.info "Finished processing: #{@target_file.split('/').last}"
  end
  
  def mksubdir
    dir = "#{@destination_dir}#{@relative_dir}"
    if @relative_dir && !File.exists?(dir)
      begin
        LOGGER.info "Creating directory: #{dir}"
        Dir.mkdir(dir)
      rescue
        LOGGER.fatal "Couldn't create directory: #{dir}. Check permissions?"
      end
    end
  end
end

pool = XPool.new options[:concurrency]

Dir.glob("#{options[:target]}**/*.{jpg,jpeg}", File::FNM_CASEFOLD) do |jpg|
  resizer = Resizer.new options[:target], jpg, options[:destination], options[:size]
  pool.schedule resizer
end

pool.shutdown
LOGGER.info "Resizing done."